# 14.4.1 제네레이터 함수의 작동방식


> 본체 안에 yield 키워드를 가진 함수는 모두 제너레이터 함수이며, 제너레이터 함수는 호출되면 제너레이터 객체를 반환하도록 만들어져있다. 즉, 제네레이터 함수는 제너레이터 팩토리라고 할 수 있다.

필자의 생각은 여기서 객체보다는 제너레이터 인스턴스를 반환한다고 표현하는게 더 정확하다 생각한다.


# 14.5 setence #4 느긋한 구현
Lazy evaluation VS eager evaluation

지능형 리스트 is eager evaluation

```
RE_WORD = re.compile('\w+')
for match in RE_WORD.finditer("hello wtf word!!!"):
	yield match.group()
```



# 14.6 제네레이터 표현식
제네레이터 표현식???
제네레이터 표현식은 제너레이터 팩토리. 즉, 제너레이터를 생성해서 반환하는 형식의 코드.


# 14.7 제너레이터 표현식: 언제 사용하나요?

논리가 간단한 경우에는 제너레이터 함수보다 표현식으로도 충분하다.  제너레이터 표현식이 여러 줄에 걸쳐 있을 때는 가독성을 위해 제너레이터 함수를 사용한다. 게다가 제너레이터 함수는 이름을 가지고 있으므로 재사용할 수도 있다.

앞에서는 전통적인 반복자로서의 제너레이터의 역할을 살펴보았다. 즉, 컬렉션에서 항목들을 꺼내오는 것이다. 그러나 제너레이터는 데이터 출처에 무관하게 값을 생성하기 위해 사용할 수도 있다.


# 14.8 또 다른 예제: 등차수열 제너레이터
arithmeticProgression

### python 강제 type 세팅
```
>>> type(str())(123)
'123'
>>> type(Decimal('.1') + 1)(1)
'Decimal('1')
```



